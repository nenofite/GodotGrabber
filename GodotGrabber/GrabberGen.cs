using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Nenofite.GodotGrabber
{
    [Generator(LanguageNames.CSharp)]
    public class GrabberGen : ISourceGenerator
    {
        public const string AttributeCs =
            @"
// <auto-generated />
using System;

namespace Nenofite.GodotGrabber
{
    public sealed class GrabAttribute : Attribute
    {
        public readonly string Path;
        public GrabAttribute(string path = null)
        {
            Path = path;
        }
    }
}
";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForPostInitialization(ctx =>
            {
                ctx.AddSource("GrabberGen.g.cs", AttributeCs);
            });
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var classesWithAttrs = context.Compilation.SyntaxTrees
                .SelectMany(
                    tree =>
                        tree.GetRoot()
                            .DescendantNodesAndSelf()
                            .OfType<ClassDeclarationSyntax>()
                            .Where(HasClassWithAttribute)
                )
                .ToArray();

            foreach (var node in classesWithAttrs)
            {
                var gf = FindGrabFields(node, context);
                if (gf == null)
                    continue;
                EmitClassImpl(context, gf);
            }
        }

        static bool HasClassWithAttribute(ClassDeclarationSyntax node)
        {
            return node.DescendantNodes()
                .Where(n => n is FieldDeclarationSyntax || n is PropertyDeclarationSyntax)
                .SelectMany(n => n.DescendantNodes())
                .Where(n => n is AttributeSyntax attr && attr.Name.ToString().Contains("Grab"))
                .Any();
        }

        static void EmitClassImpl(GeneratorExecutionContext context, ClassWithGrabFields source)
        {
            if (source == null)
                return;

            const string indent = "        ";

            var src =
                $@"
partial class {source.ClassDec.Name}
{{
    /// <summary>
    /// Set the values of all fields marked with <c>[Grab]</c>. You should usually call this in <c>_Ready()</c>.
    /// 
    /// The current value of each field will be overwritten.
    /// </summary>
    void GrabNodes()
    {{
{formatLines(source.Fields.Select(EmitField))}
    }}
}}
";

            var showNs = !source.ClassDec.ContainingNamespace.IsGlobalNamespace;
            if (showNs)
            {
                src =
                    $@"
namespace {source.ClassDec.ContainingNamespace.ToDisplayString()}
{{
{src}
}}
";
            }

            context.AddSource($"{source.ClassDec.ToDisplayString()}_Grabber.g.cs", src);

            string formatLines(IEnumerable<string> lines)
            {
                return string.Join("\n", lines.Select(ln => indent + ln));
            }
        }

        static string EmitField((ISymbol, string path) t)
        {
            var (field, path) = t;
            var localName = field.Name;
            ITypeSymbol type;
            if (field is IFieldSymbol f)
                type = f.Type;
            else if (field is IPropertySymbol p)
                type = p.Type;
            else
                return "// nop";

            return $"{localName} = GetNode<{type.ToDisplayString()}>(\"{path}\");";
        }

        static ClassWithGrabFields FindGrabFields(
            ClassDeclarationSyntax classNode,
            GeneratorExecutionContext context
        )
        {
            var sem = context.Compilation.GetSemanticModel(classNode.SyntaxTree);
            var classDec = sem.GetDeclaredSymbol(classNode);
            var fields = classNode
                .DescendantNodes()
                .Where(n => n is FieldDeclarationSyntax || n is PropertyDeclarationSyntax)
                .SelectMany(extractFields)
                .ToImmutableList();

            if (!fields.Any())
                return null;

            return new ClassWithGrabFields(classDec, fields);

            IEnumerable<(ISymbol field, string path)> extractFields(SyntaxNode node)
            {
                var atts = node.DescendantNodes().OfType<AttributeSyntax>();
                string pathOverride = null;

                foreach (var att in atts)
                {
                    var attSym = sem.GetSymbolInfo(att).Symbol as IMethodSymbol;
                    if (attSym == null)
                        continue;
                    if (
                        attSym.ContainingType?.ToDisplayString()
                        != "Nenofite.GodotGrabber.GrabAttribute"
                    )
                        continue;

                    pathOverride = ExtractPathFromAttribute(att);
                    goto foundAtt;
                }
                yield break;

                foundAtt:
                foreach (var n in node.DescendantNodes())
                {
                    if (n is VariableDeclaratorSyntax f)
                    {
                        var sym = sem.GetDeclaredSymbol(f);
                        if (sym == null)
                            continue;

                        yield return (sym, pathOverride ?? "%" + sym.Name);
                    }
                }
            }
        }

        static string ExtractPathFromAttribute(AttributeSyntax att)
        {
            var argNodes = att.ArgumentList?.Arguments.FirstOrDefault()?.DescendantNodes();
            if (argNodes == null)
                return null;

            foreach (var n in argNodes)
            {
                if (
                    n is LiteralExpressionSyntax lit
                    && lit.Kind() == SyntaxKind.StringLiteralExpression
                )
                {
                    if (lit.Token.Value is string name)
                        return name;
                }
            }

            return null;
        }

        class ClassWithGrabFields
        {
            public readonly ISymbol ClassDec;
            public readonly ImmutableList<(ISymbol, string path)> Fields;

            public ClassWithGrabFields(
                ISymbol classDec,
                ImmutableList<(ISymbol, string path)> fields
            )
            {
                ClassDec = classDec;
                Fields = fields;
            }
        }
    }
}
