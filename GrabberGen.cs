using System;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace NodeGrabber
{
    [Generator(LanguageNames.CSharp)]
    public class GrabberGen : IIncrementalGenerator
    {
        const string AttributeCs =
            @"
// <auto-generated />
namespace NodeGrabber
{
    public sealed class GrabAttribute : Attribute
    {
        public readonly string Path;
        public GrabAttribute(string path = null)
        {
            Path = path;
        }
    }
}
        ";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(
                x => x.AddSource("GrabberGen.g.cs", AttributeCs)
            );

            var ls = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: HasClassWithAttribute,
                transform: TransformClasses
            );
            context.RegisterSourceOutput(ls, EmitClasses);
        }

        static void EmitClasses(SourceProductionContext context, ClassAndFields source)
        {
            var src =
                $@"
namespace {source.ClassDec.ContainingNamespace.ToDisplayString()}
{{
    partial class {source.ClassDec.Name}
    {{
        void GrabNodes()
        {{
            // spam {string.Join("; ", source.Fields.Select(f => f.ToDisplayString()))}
        }}
    }}
}}
";
            context.AddSource($"{source.ClassDec.ToDisplayString()}_Grabber.g.cs", src);
        }

        static ClassAndFields TransformClasses(
            GeneratorSyntaxContext context,
            CancellationToken token
        )
        {
            var classNode = context.Node as ClassDeclarationSyntax;
            if (classNode == null)
                throw new Exception("huh?");

            var classDec = context.SemanticModel.GetDeclaredSymbol(classNode);
            var fields = classNode
                .DescendantNodes()
                .OfType<FieldDeclarationSyntax>()
                .Select(f => context.SemanticModel.GetDeclaredSymbol(f))
                .Where(f => f != null)
                //.Where(f => f?.ContainingType?.ToDisplayString() == "NodeGrabber.GrabAttribute")
                .ToImmutableList();
            //if (!fields.Any())
            //    return null;

            return new ClassAndFields(classDec, fields);
        }

        static bool HasClassWithAttribute(SyntaxNode node, CancellationToken token)
        {
            return node is ClassDeclarationSyntax
                && node.DescendantNodes()
                    .OfType<FieldDeclarationSyntax>()
                    .Where(f => f.AttributeLists.Any())
                    .Any();
        }

        class ClassAndFields
        {
            public readonly ISymbol ClassDec;
            public readonly ImmutableList<ISymbol> Fields;

            public ClassAndFields(ISymbol classDec, ImmutableList<ISymbol> fields)
            {
                ClassDec = classDec;
                Fields = fields;
            }
        }

        //public void Execute(GeneratorExecutionContext context)
        //{
        //    // var targets = context.Compilation.SyntaxTrees.SelectMany(st =>
        //    //     st.GetRoot()
        //    //     .DescendantNodes()
        //    //     .OfType<ClassDeclarationSyntax>()
        //    //     .SelectMany(x => x.DescendantNodes())
        //    //     .OfType<MemberDeclarationSyntax>()
        //    //     .Where(m => m.AttributeLists.Any(atts => atts.Attributes.Any(att => att.Name.Span.Equals("Grab"))))
        //    // );
        //}

        //public void Initialize(GeneratorInitializationContext context)
        //{
        //    context.RegisterForPostInitialization(x => x.AddSource("GrabberGen.g.cs", AttributeCs));
        //}
    }
}
